// Copyright (C) 2021-2023, HardenedVault Limited (https://hardenedvault.net)

#include "exploit_detect.h"

int BPFExploitDetect::bpf_program_init
(const std::string bpf_wcfi/*, std::string psd_program*/) {
    bpf = new ebpf::BPF;

    auto res = bpf->init(bpf_wcfi);
    if (!res.ok()) {
        std::cerr << "bpf init: " << res.msg() << std::endl;
        return 0;
    }

    return 1;
}

int BPFExploitDetect::bpf_wcfi_hooks_init(int count, char ** funcs, std::string hook) {
    if (count < 2) {
        std::cerr << "no kernel function specified" << std::endl;
        return 0;
    }

    for (int i = 1; i < count; i++) {
        wcfi_hooks.push_back(funcs[i]);
        std::cout << funcs[i] << ", ";
    }
    std::cout << std::endl;

    if (bpf) {
        for (auto func : wcfi_hooks) {
            auto res = bpf->attach_kprobe(func, hook);
            if (!res.ok()) {
                std::cerr << "attach: " << res.msg() << std::endl;
                return 0;
            }
        }
    } else {
        std::cerr << "bpf is invaild" << std::endl;
        return 0;
    }
    return 1;
}

void BPFExploitDetect::bpf_wcfi_stack_init(std::string stack_name) {
    wcfi_stacks = new ebpf::BPFStackTable(bpf->get_stack_table(stack_name));

    if (!wcfi_stacks)
        std::cerr << "wcfi stacks: " << stack_name << "init failed" << std::endl;
}

int BPFExploitDetect::bpf_wcfi_callsite_bitmap_init
(unsigned min, unsigned max, unsigned long init_stack) {
    wcfi_callsite_bitmap = new ebpf::BPFHashTable<unsigned, uint8_t>
            (bpf->get_hash_table<unsigned, uint8_t>("wcfi_callsite_bitmap"));

    if (!wcfi_callsite_bitmap)
        std::cerr << "failed init callsite bitmap" << std::endl;

    auto wcfi_callsite_bitmap_maxmin = new ebpf::BPFHashTable<unsigned, unsigned>
            (bpf->get_hash_table<unsigned, unsigned>("wcfi_callsite_bitmap_maxmin"));
    if (!wcfi_callsite_bitmap_maxmin)
        std::cerr << "failed init callsite bitmap maxmin" << std::endl;

    auto res = wcfi_callsite_bitmap_maxmin->update_value(0xffff, max & 0xffffffff);
    if (!res.ok())
        std::cerr << "set callsite bitmap max" << res.msg() << std::endl;

    res = wcfi_callsite_bitmap_maxmin->update_value(0x0, min & 0xffffffff);
    if (!res.ok())
        std::cerr << "set callsite bitmap min" << res.msg() << std::endl;

    auto wcfi_init_stack = new ebpf::BPFHashTable<int, unsigned long>
            (bpf->get_hash_table<int, unsigned long>("wcfi_init_stack"));
    if (!wcfi_init_stack)
        std::cerr << "failed init callsite bitmap maxmin" << std::endl;

    res = wcfi_init_stack->update_value(0x0, init_stack);
    if (!res.ok())
        std::cerr << "set callsite bitmap max" << res.msg() << std::endl;

    return 1;
}

void BPFExploitDetect::bpf_wcfi_callsite_bitmap_update
(unsigned long addr, uint8_t new_flag) {
    unsigned idx = (unsigned)(addr & 0xffffffff);
    uint8_t flag = 0;

    if(wcfi_callsite_bitmap) {
        auto res = wcfi_callsite_bitmap->update_value(idx, new_flag);
        if (!res.ok())
            std::cerr << "set callsite bitmap: " << res.msg() << std::endl;
    } else
        std::cerr << "set callsite bitmap: callsite bitmap not inited" << std::endl;
}

std::vector<uintptr_t> BPFExploitDetect::bpf_wcfi_get_stack_addr(int id) {
    return wcfi_stacks->get_stack_addr(id);
}

int BPFExploitDetect::bpf_wcfi_ksyms_init(void) {
    wcfi_ksyms = bcc_symcache_new(-1, nullptr);

    if (!wcfi_ksyms) {
        std::cerr << "failed creat symcache" << std::endl;
        return 0;
    }

    wcfi_kstext = bpf_wcfi_ksyms_resolve_name("", "_stext");

    if (!wcfi_kstext) {
        std::cerr << "failed to initialize _stext" << std::endl;
        return 0;
    }

    wcfi_ketext = bpf_wcfi_ksyms_resolve_name("", "_etext");

    if (!wcfi_ketext) {
        std::cerr << "failed to initialize _etext" << std::endl;
        return 0;
    }

    return 1;
}

void BPFExploitDetect::bpf_wcfi_ksyms_refresh() {
    if (wcfi_ksyms)
        bcc_symcache_refresh(wcfi_ksyms);
}

std::string BPFExploitDetect::bpf_wcfi_ksyms_info(unsigned long ip) {
    bcc_symbol sym;

    if(bcc_symcache_resolve(wcfi_ksyms, ip, &sym) != 0)
        return "[UNKNOWN]";
    else
        return sym.name +
                std::string("(")+ /*std::string(sym.offset) +*/ std::string(") ") +
                std::string("[") + sym.module + std::string("]");
}

std::string BPFExploitDetect::bpf_wcfi_ksyms_resolve(unsigned long ip) {
    bcc_symbol sym;

    if(bcc_symcache_resolve(wcfi_ksyms, ip, &sym) != 0)
        return "[UNKNOWN]";
    else
        return sym.name;
}

void BPFExploitDetect::bpf_wcfi_text(unsigned long *start, unsigned long *end) {
    if (start && wcfi_kstext != 0)
        *start = wcfi_kstext;
    if (end && wcfi_ketext != 0)
        *end = wcfi_ketext;
}

unsigned long BPFExploitDetect::bpf_wcfi_ksyms_resolve_name
(const char *modname, const char *symname) {
    unsigned long addr = 0;

    if (bcc_symcache_resolve_name(wcfi_ksyms, modname, symname, &addr) == 0)
        return addr;
    else
        return 0;
}

std::vector<unsigned long> BPFExploitDetect::bpf_wcfi_ksyms_list_address
(std::map<std::string, bool> funcs) {
    std::vector<unsigned long> addrs;

    for(unsigned long ip = wcfi_kstext; ip < wcfi_ketext; ip++) {
        std::string name = bpf_wcfi_ksyms_resolve(ip);
        if (funcs.find(name) != funcs.end()) {
            addrs.push_back(ip);
        }
    }

    return addrs;
}

int BPFExploitDetect::bpf_wcfi_perf_buffer_init
(std::string stack, void (*handle_output)(void *, void *, int)) {
    auto res = bpf->open_perf_buffer(stack, handle_output, NULL, NULL, 0x1000);

    if (!res.ok()) {
        std::cerr << res.msg() << std::endl;
        return 0;
    }

    perf_buffer = bpf->get_perf_buffer(stack);

    if (!perf_buffer) {
        std::cerr << "failed get_perf_buffer" << std::endl;
        return 0;
    }

    return 1;
}

void BPFExploitDetect::bpf_wcfi_perf_poll(void) {
    if (perf_buffer != nullptr) {
        perf_buffer->poll(100);
    }
}
